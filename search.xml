<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树的递归和非递归算法</title>
      <link href="blog/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
      <url>blog/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此文介绍了二叉树的使用递归和非递归算法遍历先序、中序、后序</p></blockquote><p><strong>本文会随着作者日常学习进行补充及内容修正</strong></p><hr><h2 id="树的结构定义"><a href="#树的结构定义" class="headerlink" title="树的结构定义"></a>树的结构定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">private</span> BinTree left;</span><br><span class="line">    <span class="keyword">private</span> BinTree right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">BinTree</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        data=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        BinTree b1 = <span class="keyword">new</span> BinTree(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        BinTree b2 = <span class="keyword">new</span> BinTree(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        BinTree b3 = <span class="keyword">new</span> BinTree(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        BinTree b4 = <span class="keyword">new</span> BinTree(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">        BinTree b5 = <span class="keyword">new</span> BinTree(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *      a</span></span><br><span class="line"><span class="comment">         *     / \</span></span><br><span class="line"><span class="comment">         *    b   c</span></span><br><span class="line"><span class="comment">         *   / \</span></span><br><span class="line"><span class="comment">         *  d   e</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        b1.left = b2;</span><br><span class="line">        b1.right = b3;</span><br><span class="line">        b2.left = b4;</span><br><span class="line">        b2.right = b5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(t.data);</span><br><span class="line">    pre(t.left);</span><br><span class="line">    pre(t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iN(t.left);</span><br><span class="line">    System.out.print(t.data);</span><br><span class="line">    in(t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pos</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos(t.left);</span><br><span class="line">    pos(t.right);</span><br><span class="line">    System.out.print(t.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h2><p><strong>push()入栈</strong></p><p><strong>pop()返回栈顶元素，并在栈中删除它</strong></p><p><strong>peek() 返回栈顶元素，但不在栈中删除它。</strong></p><h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pre1</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">Stack&lt;BinTree&gt; s=<span class="keyword">new</span> Stack&lt;BinTree&gt;();</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="keyword">null</span> || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(t.data);</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左边切换到右边</span></span><br><span class="line">        <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">            t=s.pop();</span><br><span class="line">            t=t.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">in1</span><span class="params">(BinTree t)</span></span>&#123;</span><br><span class="line">Stack&lt;BinTree&gt; s = <span class="keyword">new</span> Stack&lt;BinTree&gt;();</span><br><span class="line">    <span class="keyword">while</span>(t!=<span class="keyword">null</span> || !s.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t.left;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.empey())&#123;</span><br><span class="line">            t=s.pop();</span><br><span class="line">            System.out.print(t.data);</span><br><span class="line">            t=t.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Pos1</span><span class="params">(BinTree t)</span> </span>&#123;</span><br><span class="line">Stack&lt;BinTree&gt; s = <span class="keyword">new</span> Stack&lt;BinTree&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Integer i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            s.push(t);</span><br><span class="line">            s2.push(<span class="number">0</span>);</span><br><span class="line">            t = t.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s2.peek().equals(i)) &#123;</span><br><span class="line">            s2.pop();</span><br><span class="line">            System.out.print(s.pop().data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!s.empty()) &#123;</span><br><span class="line">            s2.pop();</span><br><span class="line">            s2.push(<span class="number">1</span>);</span><br><span class="line">            t = s.peek();</span><br><span class="line">            t = t.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单点登录</title>
      <link href="blog/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/"/>
      <url>blog/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此文介绍了单点登录流程、JWT、token</p></blockquote><p><strong>本文会随着作者日常学习进行补充及内容修正</strong></p><hr><h2 id="单点登录流程"><a href="#单点登录流程" class="headerlink" title="单点登录流程"></a>单点登录流程</h2><ol><li>根据用户名查找</li><li>如果为null，就是用户不存在</li><li>密码匹配，如果不匹配，就是密码不正确</li><li>Jwt生成token</li><li>将token存入redis中，access token过期时间短，refresh_token过期时间长。</li></ol><hr><h2 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h2><p>第一部分我们称它为头部（header)</p><p>第二部分我们称其为载荷（payload)。载荷就是存放有效信息的地方。</p><p>第三部分是签证（signature)</p><p>JWT生成的token是这样的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">XXXXXX</span><span class="selector-class">.XXXXXXX</span><span class="selector-class">.XXXXXXX</span></span><br></pre></td></tr></table></figure><blockquote><p>生成的token，是3段，用<code>.</code>连接。</p></blockquote><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p>用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。<br>  例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="载荷"><a href="#载荷" class="headerlink" title="载荷"></a>载荷</h3><p>其实就是自定义的数据，一般<code>存储用户Id</code>，<code>过期时间</code>等信息。也就是JWT的核心所在，因为这些数据就是使后端知道此token是哪个用户已经登录的凭证。而且这些数据是存在token里面的，由前端携带，所以后端几乎不需要保存任何数据。<br>  例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;uid&quot;</span>: <span class="string">&quot;xxxxidid&quot;</span>,  <span class="comment">//用户id</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="string">&quot;12121212&quot;</span>  <span class="comment">//过期时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p>签名其实就是：<br> 1.头部和载荷<code>各自base64加密后用.连接起来</code>，然后就形成了xxx.xx的前两段token。<br> 2.最后一段token的形成是，前两段加入一个密匙用HS256算法或者其他算法加密形成。<br> 3.所以token的3段形成就是在签名处形成的。</p><hr><h2 id="访问令牌（access-token）和刷新令牌-refresh-token"><a href="#访问令牌（access-token）和刷新令牌-refresh-token" class="headerlink" title="访问令牌（access token）和刷新令牌(refresh_token )"></a>访问令牌（access token）和刷新令牌(refresh_token )</h2><ul><li><p>当用户登录的时候，生成<code>access_token</code>和<code>refresh_token</code>，并返回给APP。</p></li><li><p><code>access_token</code>是用于<code>身份验证</code>的。</p></li><li><p>当<code>access_token</code>失效时，APP使用<code>refresh_token</code>来请求<code>刷新token</code>。</p></li><li><p>如果<code>refresh_token</code>过期，需要用户重新登录，</p><p>也就是说，用户每一次登陆的时候refresh_token都会重新更改。</p></li><li><p>token的过期时间是分钟级别的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找法</title>
      <link href="blog/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
      <url>blog/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此文介绍了二分查找法</p></blockquote><p><strong>本文会随着作者日常学习进行补充及内容修正</strong></p><hr><ul><li>N*2  =》N&lt;&lt;1</li><li>N*4  =》N&lt;&lt;2</li><li>N/2  =》N&gt;&gt;1</li><li>N*2+1  =》(N&lt;&lt;1)|1</li><li><code>+和-</code>比<code>&gt;&gt;和&lt;&lt;</code>运算符优先级高</li></ul><div class="table-container"><table><thead><tr><th>优先级</th><th>描述</th><th>运算符</th></tr></thead><tbody><tr><td>1</td><td>括号</td><td>()、[]</td></tr><tr><td>2</td><td>正负号</td><td>+、-</td></tr><tr><td>3</td><td>自增自减，非</td><td>++、—、!</td></tr><tr><td>4</td><td>乘除，取余</td><td>*、/、%</td></tr><tr><td>5</td><td>加减</td><td>+、-</td></tr><tr><td>6</td><td>移位运算</td><td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td></tr><tr><td>7</td><td>大小关系</td><td>&gt;、&gt;=、&lt;、&lt;=</td></tr><tr><td>8</td><td>相等关系</td><td>==、!=</td></tr><tr><td>9</td><td>按位与</td><td>&amp;</td></tr><tr><td>10</td><td>按位异或</td><td>^</td></tr><tr><td>11</td><td>按位或</td><td>\</td><td></td></tr><tr><td>12</td><td>逻辑与</td><td>&amp;&amp;</td></tr><tr><td>13</td><td>逻辑或</td><td>\</td><td>\</td><td></td></tr><tr><td>14</td><td>条件运算</td><td>?:</td></tr><tr><td>15</td><td>赋值运算</td><td>=、+=、-=、*=、/=、%=</td></tr><tr><td>16</td><td>位赋值运算</td><td>&amp;=、\</td><td>=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td></tr></tbody></table></div><h2 id="1-找某个数是否存在"><a href="#1-找某个数是否存在" class="headerlink" title="1.找某个数是否存在"></a>1.找某个数是否存在</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R=arr.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">        mid=L+((R-L)&gt;&gt;<span class="number">1</span>); <span class="comment">//L+(R-L)/2</span></span><br><span class="line"><span class="keyword">if</span>(arr[mid]==num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;num)&#123;</span><br><span class="line">            R=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            L=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[L] == num;<span class="comment">//相等返回true，否则返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-找某个数的最左侧位置"><a href="#2-找某个数的最左侧位置" class="headerlink" title="2.找某个数的最左侧位置"></a>2.找某个数的最左侧位置</h2><p>例：112233445</p><p>查找&gt;=2，最左则位置为第2个位置</p><ul><li><p><strong>第一轮</strong><code>11223344</code></p><p>mid = 7 / 2 = 3   即数字2</p><p>2满足&gt;=num的要求   R=3-1=2 ，即2  <code>index=3</code></p></li><li><p><strong>第二轮</strong><code>112</code> 23344</p><p>mid =（2-0）/ 2 = 1 ，即数字1</p><p>1不满足 &gt;= num  L=1+1=2  </p></li><li><p><strong>第三轮</strong> <code>1</code> 12 23344</p><p>mid = (2-  2)  / 2 = 0 ，即数字1</p><p>1不满足 &gt;= num 的要求 </p></li><li><p><strong>最终返回index=3</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt;= num)&#123;</span><br><span class="line">            index =mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-局部最小值"><a href="#3-局部最小值" class="headerlink" title="3.局部最小值"></a>3.局部最小值</h2><p>例：134324</p><p>其中1、2为局部最小值,下面只返回一个局部最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]&lt;arr[<span class="number">1</span>]||arr.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//第一位比第二位小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[arr.length-<span class="number">2</span>]&gt;arr[arr.length-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> arr.length-<span class="number">1</span>; <span class="comment">//第N位比倒数第N-1位小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> L=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R=arr.length-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            mid=L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[mid]&gt;arr[mid-<span class="number">1</span>])&#123;</span><br><span class="line">                R=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;arr[mid+<span class="number">1</span>])&#123;</span><br><span class="line">                L=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// 前大后大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此文介绍了冒泡排序、选择排序、插入排序 </p><p>排序可视化网站 <a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a> 可以更快速理解！</p></blockquote><p><strong>本文会随着作者日常学习进行补充及内容修正</strong></p><hr><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>通过多次遍历，判断相邻两个之间大小,每次都能取到最大值</p><p>第一次遍历0~N-1  最大值为N-1位</p><p>第二次遍历0~N-2  第二大值为N-2位</p><p>。。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e = arr.length - <span class="number">1</span>;e &gt; <span class="number">0</span>;e--)&#123;   <span class="comment">//最后一次是e=1，下面的遍历为0~1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; e;i++)&#123;    <span class="comment">//0~e</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">               swap(arr,i,i++); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交互位置 如果i和j是同一个位置，会出错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr ,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">    arr[j]=arr[i]^arr[j];</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>遍历查找最小值，然后交互位置</p><p>第一次遍历0~N-1  最小值为第0位</p><p>第二次遍历1~N-1  第二小值为第1位</p><p>。。。。</p><p>总结为i~N-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; arr.length;j++)&#123;</span><br><span class="line">            minIndex = arr[j] &lt; arr[mindex] ? j :minIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i ,minIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交互位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr ,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp =arr[i];</span><br><span class="line">    arr[i] =arr[j];</span><br><span class="line">    arr[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>0~1上有序</p><p>0~2上有序</p><p>。。。。</p><p>0~i上有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--)&#123;   </span><br><span class="line">          swap(arr, j ,j + <span class="number">1</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交互位置 如果i和j是同一个位置，会出错</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr ,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">    arr[j]=arr[i]^arr[j];</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ工作模型</title>
      <link href="blog/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>blog/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此文介绍了RabbitMQ工作模型</p></blockquote><p><strong>本文会随着作者日常学习进行补充及内容修正</strong></p><hr><h1 id="1-什么是RabbitMQ"><a href="#1-什么是RabbitMQ" class="headerlink" title="1.什么是RabbitMQ"></a>1.什么是<strong>RabbitMQ</strong></h1><p>​    MQ是Message Queue，也就是<code>消息队列</code>，是一个<code>消息中间件</code>,使用Erlang语言写的。</p><hr><h1 id="2-工作模型"><a href="#2-工作模型" class="headerlink" title="2.工作模型"></a>2.工作模型</h1><p><img src="https://s2.loli.net/2021/12/12/nd1skcB3uZeAwma.png" alt="RabbitMQ的工作模型"></p><p>（1）<code>Broker</code>：中介。提供一种传输服务，维护一条从生产者到消费者的传输线路，保证消息数据能按照指定的方式传输。</p><p>（2）<code>Exchange</code>：消息交换机。指定消息按照什么规则路由到哪个队列Queue。生产者不能直接和Queue建立连接，而是通过交换机进行消息分发。</p><p>（3）<code>Queue</code>：消息队列。消息的载体，每条消息都会被投送到一个或多个队列中。</p><p>（4）<code>Binding</code>：绑定。作用就是将Exchange和Queue按照某种路由规则绑定起来。</p><p>（5）<code>RoutingKey</code>：路由关键字。消息所携带的标志，Exchange根据RoutingKey进行消息投递。</p><p>（6）<code>VHost</code>：虚拟主机。一个Broker可以有多个虚拟主机，用作不同用户的权限分离。一个虚拟主机持有一组Exchange、Queue和Binding。</p><p>（7）<code>Producer</code>：消息生产者。主要将消息投递到对应的Exchange上面。一般是独立的程序。</p><p>（8）<code>Consumer</code>：消息消费者。消息的接收者，一般是独立的程序。</p><p>（9）<code>Channel</code>：消息通道，也称信道，是连接消费者和Broker的虚拟连接，如果直接让消费者和Broker建立TCP的连接，会让Broker有性能损耗。在客户端的每个连接里可以建立多个Channel，每个Channel代表一个会话任务。</p><hr><h1 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3.工作流程"></a>3.工作流程</h1><ol><li>生产者通过消息通道(channel)与RabbitMQ建立连接</li><li>消息传送到交换机（Exchange），并且消息上有对应的标志关键字(RoutingKey)</li><li>交换机Exchange接收到消息后，就根据消息的RoutingKey和已经设置的binding，进行消息路由（投递），将消息投递到一个或多个队列(Queue)里</li><li>消费者(Consumer)客户端从对应的队列中获取并处理消息</li></ol><hr><h1 id="4-Exchange类型"><a href="#4-Exchange类型" class="headerlink" title="4.Exchange类型"></a>4.Exchange类型</h1><ul><li><p>Direct<br>   全匹配式传递。当RoutingKey和消息标志完全一样才会存放到对应的队列</p></li><li><p>Topic<br>   广播式全部传递。息都会被投递到所有与此Exchange绑定的queue中</p></li><li><p>Fanout<br>   匹配式传递</p><p>​    #表示0个或多个单词</p><p>​     *表示1个</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基本概念</title>
      <link href="blog/Redis/"/>
      <url>blog/Redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此文介绍了Redis的持久化、发布订阅、哨兵模式</p></blockquote><p><strong>本文会随着作者日常学习进行补充及内容修正</strong></p><hr><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>持久化包括了<code>RDB</code>和<code>AOF</code></p><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><blockquote><p>什么是RDB</p></blockquote><p><img src="https://i.loli.net/2020/12/10/8bZ21fKTvtBWjdl.png" alt="RDB"></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><p>rdb保存的文件是dump.rdb</p><p>Redis会<code>单独创建（fork）一个子进程来进行持久化</code>，会先将数据<code>写入到一个临时文件</code>中，待持久化过程都结束了，再用这个<code>临时文件替换</code>上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！</p><p><strong>优点</strong>：</p><ol><li><p>适合大规模的数据恢复！</p></li><li><p>对数据的完整性要不高！</p></li></ol><p><strong>缺点：</strong></p><ol><li><p>需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！</p></li><li><p>fork进程的时候，会占用一定的内容空间！</p></li></ol><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><p>将我们的所有命令都记录下来，恢复的时候就把这个文件全部在执行一遍！</p><blockquote><p>AOF是什么 </p></blockquote><p><img src="https://i.loli.net/2020/12/11/R9bNlX8x27iBQtM.png" alt="AOF"></p><p>以<code>日志的形式</code>来记录每个<code>写操作</code>，将Redis执行过的所有指令记录下来（<code>读操作不记录</code>），<code>只许追加</code>文件但<code>不可以改写</code>文件，redis启动之初会读取该文件<code>重新构建数据</code>，换言之，redis重启的话就根据日志文件的内容将写指令<code>从前到后执行</code>一次以完成数据的恢复工作</p><p><strong>Aof保存的是 appendonly.aof 文件</strong></p><p> 默认是不开启的，需要将 appendonly 改为yes就开启了 aof！重启，redis 就可以生效了！</p><p>如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件</p><p><strong>redis 给我们提供了一个工具 redis-check-aof —fix</strong></p><blockquote><p>重写规则说明</p></blockquote><p>aof 默认就是文件的无限追加，文件会越来越大！</p><p> 如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p><blockquote><p>优点和缺点！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字</span><br><span class="line"># appendfsync always # 每次修改都会 sync。消耗性能</span><br><span class="line">appendfsync everysec # 每秒执行一次 sync，可能会丢失这1s的数据！</span><br><span class="line"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span><br><span class="line"># rewrite 重写，</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li><p>每一次修改都同步，文件的完整会更加好！</p></li><li><p>每秒同步一次，可能会丢失一秒的数据</p></li></ol><p>缺点：</p><ol><li><p>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</p></li><li><p>Aof 运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</p></li></ol><p><strong>扩展：</strong></p><ol><li><code>RDB 持久化</code>方式能够在指定的时间间隔内对你的数据进行<code>快照存储</code></li><li><code>AOF 持久化</code>方式<code>记录</code>每次对服务器<code>写的操作</code>，当<code>服务器重启</code>的时候会<code>重新执行</code>这些<code>命令</code>来<code>恢复</code>原始的<code>数据</code>，AOF命令以Redis 协议<code>追加保存每次写的操作</code>到文件末尾，Redis还能对AOF文件进行<code>后台重写</code>，使得AOF文件的体积不至于过大。</li><li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</li><li>同时开启两种持久化方式</li></ol><ul><li><p>在这种情况下，当redis重启的时候会<code>优先载入AOF文件</code>来恢复原始的数据，</p><p>因为在通常情况下AOF文件保存的数据集要比RDB文件保存的<code>数据集要完整</code>。</p></li><li><p>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？</p><p>作者建议不要，因为<code>RDB更适合用于备份数据库</code>（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。</p></li></ul><ol><li>性能建议</li></ol><ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要<code>15分钟</code>备份一次就够<br>了，只保留 <code>save 900 1</code>这条规则。</li><li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自<br>己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产<br>生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite<br>的频率，AOF重写的<code>基础大小默认值64M</code>太小了，可以设到5G以上，默认超过原大小100%大小重<br>写可以改到适当的数值。</li><li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也<br>减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，<br>启动脚本也要比较两个 Master/Slave 中的 RDB文件，<code>载入较新</code>的那个，微博就是这种架构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 TCP 、UDP协议的 Socket 程序函数调用过程</title>
      <link href="blog/%E5%9F%BA%E4%BA%8E%20TCP%20%E3%80%81UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%20Socket%20%E7%A8%8B%E5%BA%8F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
      <url>blog/%E5%9F%BA%E4%BA%8E%20TCP%20%E3%80%81UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%20Socket%20%E7%A8%8B%E5%BA%8F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此文介绍了基于 TCP 、UDP协议的 Socket 程序函数调用过程</p></blockquote><p><strong>本文会随着作者日常学习进行补充及内容修正</strong></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>TCP 协议</code>是基于数据流的，所以设置为 SOCK_STREAM，而 <code>UDP 协议</code>是基于数据报的，因而设置为 SOCK_DGRAM。</p><h1 id="基于-TCP-协议的-Socket-程序函数调用过程"><a href="#基于-TCP-协议的-Socket-程序函数调用过程" class="headerlink" title="基于 TCP 协议的 Socket 程序函数调用过程"></a>基于 TCP 协议的 Socket 程序函数调用过程</h1><h2 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h2><p>TCP 的服务端要先<code>监听一个端口</code>，一般是先<code>调用 bind 函数</code>，给这个 Socket 赋予<code>一个 IP 地址和端口</code>。当服务端有了 IP 和端口号，就可以<code>调用 listen 函数监听</code>,服务端就<code>进入了 listen 状态</code>，这个时候<code>客户端就可以发起连接</code>。 在<code>内核</code>中，为每个 Socket<code>维护两个队列</code>。一个是<code>已经建立了连接</code>的队列，这时候连接<code>三次握手已经完毕</code>，处于 <code>established 状态</code>；一个是<code>还没有完全建立连接</code>的队列，这个时候<code>三次握手还没完成</code>，处于<code>syn_rcvd 的状态</code>。 接下来，服务端<code>调用 accept 函数</code>，拿出一个<code>已经完成的连接</code>进行处理。如果<code>还没有完成，就要等着</code>。 在服务端等待的时候，客户端可以通过<code>connect 函数发起连接</code>。先在参数中指明要<code>连接的 IP 地址和端口号</code>，然后开始<code>发起三次握手</code>。内核会给客户端分配一个临时的<code>端口</code>。一旦握手成功，服务端的 <code>accept</code>就会<code>返回另一个 Socket</code>。 这是一个经常考的知识点，<strong>就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作监听 Socket，一个叫作已连接 Socket</strong>。 连接建立成功之后，双方开始通过<code>read 和 write 函数来读写数据</code>，就像往一个文件流里面写东西一样。 </p><p><img src="TCP_socket.png" alt="基于 TCP 协议的 Socket 程序函数调用过程"></p><h2 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;本机 IP, 本机端口, 对端 IP, 对端端口&#125;</span><br></pre></td></tr></table></figure><p><strong>只要任意一个参数发生变化，就是一个新的连接</strong></p><hr><h1 id="基于-UDP-协议的-Socket-程序函数调用过程"><a href="#基于-UDP-协议的-Socket-程序函数调用过程" class="headerlink" title="基于 UDP 协议的 Socket 程序函数调用过程"></a>基于 UDP 协议的 Socket 程序函数调用过程</h1><p>UDP 是没有连接的，所以<code>不需要三次握手</code>，也就<code>不需要调用 listen 和 connect</code>，但是UDP 的交互仍然<code>需要 IP 和端口号</code>，因而也<code>需要 bind</code>。UDP 是<code>没有维护连接状态</code>的，因而不需要每对连接建立一组 Socket，而是<code>只要有 一个 Socket</code>，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，都<code>调用 sendto 和 recvfrom</code>，就可以传入 IP 地址和端口。</p><p><img src="UDP_socket.png" alt="基于 UDP 协议的 Socket 程序函数调用过程"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型</title>
      <link href="blog/IO%E6%A8%A1%E5%9E%8B/"/>
      <url>blog/IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此文介绍了I/O模型的基本概念</p></blockquote><p><strong>本文会随着作者日常学习进行补充及内容修正</strong></p><hr><h1 id="I-O模型的概念"><a href="#I-O模型的概念" class="headerlink" title="I/O模型的概念"></a>I/O模型的概念</h1><p><code>I/O 模型</code>简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。<br><code>Java</code> 共支持 <code>3 种</code>网络编程模型 I/O 模式：<strong><code>BIO</code>、<code>NIO</code>、<code>AIO</code></strong>。</p><h2 id="BIO模型"><a href="#BIO模型" class="headerlink" title="BIO模型"></a>BIO模型</h2><p><code>BIO</code>：同步并<code>阻塞</code>（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。</p><p><img src="BIO.png" alt="BIO模型"></p><h2 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h2><p><code>NIO</code>：同步<code>非阻塞</code>，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。</p><p><img src="NIO.png" alt="NIO模型"></p><h2 id="AIO模型"><a href="#AIO模型" class="headerlink" title="AIO模型"></a>AIO模型</h2><p><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h1 id="BIO、NIO、AIO-使用场景分析"><a href="#BIO、NIO、AIO-使用场景分析" class="headerlink" title="BIO、NIO、AIO 使用场景分析"></a>BIO、NIO、AIO 使用场景分析</h1><p><code>BIO</code> 方式适用于<code>连接数目比较小且固定</code>的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序简单易理解。<br><code>NIO</code> 方式适用于<code>连接数目多且连接比较短</code>（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持。<br><code>AIO</code> 方式使用于<code>连接数目多且连接比较长</code>（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级功能</title>
      <link href="blog/%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/"/>
      <url>blog/%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="相册编辑方式"><a href="#相册编辑方式" class="headerlink" title="相册编辑方式"></a>相册编辑方式</h1><h2 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h2><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;gallery-group-main&quot;&gt;</span><br><span class="line">&#123;% galleryGroup [name] [description] [link] [img-url] %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述文字</td></tr><tr><td>link</td><td>图库链接</td></tr><tr><td>img-url</td><td>封面图片链接,可以是网址，也可以是本地文件链接</td></tr></tbody></table></div><p>可以同时嵌套多个<code>galleryGroup</code>,例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">&lt;div class&#x3D;&quot;gallery-group-main&quot;&gt;</span><br><span class="line">&#123;% galleryGroup &quot;壁纸&quot; &quot;收藏的一些壁纸&quot; &quot;&#x2F;Gallery&#x2F;wallpaper&quot; &quot;&#x2F;Gallery&#x2F;01&#x2F;5.jpg&quot; %&#125;</span><br><span class="line">&#123;% galleryGroup &quot;游戏&quot; &quot;一些游戏图片&quot; &quot;&#x2F;Gallery&#x2F;games&quot; &quot;&#x2F;Gallery&#x2F;02&#x2F;5.jpg&quot; %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="相册图片自动排版"><a href="#相册图片自动排版" class="headerlink" title="相册图片自动排版"></a>相册图片自动排版</h2><p>Gallery相册会自动根据图片宽高进行排版，可用于相册子页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![图片描述](图片链接)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>直接在gallery标签内使用markdown的插入图片语句: <code>![图片描述](图片链接)</code> 就行，数量不限。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](&#x2F;Gallery&#x2F;02&#x2F;1.jpg)</span><br><span class="line">![](&#x2F;Gallery&#x2F;02&#x2F;2.jpg)</span><br><span class="line">![](&#x2F;Gallery&#x2F;02&#x2F;3.jpg)</span><br><span class="line">![](&#x2F;Gallery&#x2F;02&#x2F;4.jpg)</span><br><span class="line">![](&#x2F;Gallery&#x2F;02&#x2F;5.jpg)</span><br><span class="line">![](&#x2F;Gallery&#x2F;02&#x2F;6.jpg)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><h2 id="文字底纹"><a href="#文字底纹" class="headerlink" title="文字底纹"></a>文字底纹</h2><p>可以给一部分文字设置各种颜色的底纹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>text</td><td>文本内容</td></tr><tr><td>color</td><td>[可选] 颜色,默认为 <code>default</code> 可选值：<code>default</code> / <code>blue</code> / <code>pink</code> / <code>red</code> / <code>purple</code> / <code>orange</code> / <code>green</code></td></tr></tbody></table></div><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line">&#123;% label 日照 red %&#125;香炉生&#123;% label 紫烟 purple %&#125;，遥看&#123;% label 瀑布 blue %&#125;挂前川。</span><br><span class="line">飞流直下&#123;% label 三千尺 orange %&#125;，疑是&#123;% label 银河 pink %&#125;落九天。</span><br></pre></td></tr></table></figure><p><mark class="hl-label red">日照</mark> 香炉生<mark class="hl-label purple">紫烟</mark> ，遥看<mark class="hl-label blue">瀑布</mark> 挂前川。<br>飞流直下<mark class="hl-label orange">三千尺</mark> ，疑是<mark class="hl-label pink">银河</mark> 落九天。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章编辑</title>
      <link href="blog/done/"/>
      <url>blog/done/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文章编辑方式"><a href="#文章编辑方式" class="headerlink" title="文章编辑方式"></a>文章编辑方式</h1><hr><blockquote><p>文章书写格式：</p></blockquote><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>title</td><td>页面的标题</td></tr><tr><td>date</td><td>页面创建日期，一般自动生成。</td></tr><tr><td>updated</td><td>[可选] 页面更新日期</td></tr><tr><td>sticky</td><td>[可选]文章置顶 可选值： <code>任意数字</code>(数值越大，置顶的优先级越大) \ <code>false</code></td></tr><tr><td>tags</td><td>[可选] 文章的标签，设置了标签后会在标签页面自动更新</td></tr><tr><td>categories</td><td>[可选] 文章的分类，设置了分类后会在分类页面自动更新</td></tr><tr><td>keywords</td><td>[可选] 关键字</td></tr><tr><td>description</td><td>[可选] 页面描述</td></tr><tr><td>cover</td><td>[可选] 网站主页显示文章的缩略图，如果没设置<code>top_img</code>,文章顶部则显示此图片。 可设置为 <code>图片地址</code> 、 <code>false</code> 、留空 (不设置则显示默认图片)</td></tr><tr><td>top_img</td><td>[可选] 页面顶部图片(不设置则显示默认图片) 可设置为 <code>图片地址</code> 或 <code>颜色</code></td></tr><tr><td>comments</td><td>[可选]页面评论（需要配置评论系统）, 可选值：<code>true</code> \ <code>false</code></td></tr><tr><td>toc</td><td>[可选] 文章目录 可选值：<code>true</code> \ <code>false</code></td></tr><tr><td>toc_number</td><td>[可选] 目录每个标题生成对应序号 可选值：<code>true</code> \ <code>false</code></td></tr><tr><td>mathjax</td><td>[可选]数学公式插件 可选值：<code>true</code> \ <code>false</code></td></tr><tr><td>aside</td><td>[可选] 显示侧边栏 可选值：<code>true</code> \ <code>false</code></td></tr><tr><td>highlight_shrink</td><td>[可选] 设置代码框是否展开 可选值：<code>true</code> \ <code>false</code></td></tr><tr><td>copyright</td><td>[可选] 文章版权模块（启用后复制内容会加入设置的版权信息） 可选值：<code>true</code> \ <code>false</code></td></tr><tr><td>copyright_author</td><td>[可选] 文章版权模块<code>作者名</code></td></tr><tr><td>copyright_author_href</td><td>[可选] 文章版权模块<code>作者主页链接</code></td></tr><tr><td>copyright_url</td><td>[可选] 文章版权模块<code>文章链接</code></td></tr><tr><td>copyright_info</td><td>[可选] 文章版权模块<code>版权声明</code>文字</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
